fn format(type u8str x)
{
    guess cut_string ::= x[type pair(x.find('i'), x.find('.'))]

    cut_string.insert("XXXXX", 2)

    ``Are none and nullptr that important to be reserved identifiers for their types?

    "${emeka}"
    "{9*0} {{  }}"
    "\${2*2}"

    "@{emeka}"
    
    iter 4 0 : (default, =, .step ::= 2)
    r_l(+)
    type int32 match
    type match int32
    (1, 2, 3 4, 5)
    f(1, 2, 3, 4 5)
    f(1, 2, +, 4, 5)
    f(1, +2)

    type int32 match ::= 3
}

fn panny(typeof(class_mut) me) //for getting the type of a class easily
{
    #(1, 2, 3, 4) | fcn

    iter e : (1, 10, -2)
    {

    }

    do: type int a(3)
    emeka(), #()|emeka
    while true;
}

fn main()
{
    type fn (type int, type int)type int ::= main
    type fn (int32, int32, int32) bin32
    type (int32, int32, int32) bin32
    guess g ::= fn();

    fcn(fn open(){})
    type fn(u8string)int32: "imut_lref" a ::= fn master(){}
    type fn(u8string)int32: "imut_lref" a ::= fn(){}

    plain_ptr<fn(u8string)int32> g ::= fn(){}

    fn gas(int32 a, int8 int8){}(2, 0`i8)

    gasup(fn kase(){})
    fn(){}()

    //temporary object of function type
    type fn(int32)int32 {}
    //unnamed function
    fn(int32)int32{  }

    match e:i{case 2: {}; default: 34}
    match e:i{case(3, 4, 5): emeka}
    println!("{}", match e:i{case 2: {} case<int32>: 2 default: 23})
    
    array[type pair(0, 3)]
    array[0..3]
    (0..3).to_it()

    guess array ::= type f_array(3, 10112‚ÇÉ)
    guess (a, b, c) ::= array
    How will i:
    1. Make **a** an immutable reference to element[1]
    2. Make **b** a mutable reference to element[2]
    3. Make **c** copy it's value

    Can be done if the they are directly initialized:
    guess (a, b, c) ::= #(imut_lref array[1], mut_lref array[2], cp array[3])

    guess a ::= &imut a;
    guess a ::= imut a;
    gmem -> is back

    :(2, 3, 4)|fcn
    #(2, 3, 4)|fcn

    iter _ : (1, 3, -1) output(2, 3)
    rng _ : (1~7) output(2, 3)

    named_pt red, blue, seal{}
    named_st color{type red, type blue, type seal}

    fn current_color(type color c) type any<?>
    {
        match c:i{ case<red, blue, seal>: give type any(i) }
    }

    fn main()
    {
        guess curr_color := current_color()
    }
    &d.goand

    iter i:(desired_digits, 0, -1)
    {

    }
    for infer i := desired_digits; i < 0; --i:
    {

    }
    3,,4
    3,,5
    3,:4
    3,:3
    3~3

    b = $(2, 4, 5, 6)
    $(2, 3, 4, 5, 6) + $(2, 3, 4, 5)
    type ustr a()
    a[3,,5]

    infer a := 2, 3
    guess a := 3, 4
    auto a := 3, 4

    #[list_name_space_content(boost, no_namespaces, no_functions)]

    3,,4
    3,,4
    3~4

    - value references would different type different from non-value-reference, only it's mutability status would not be different
    - stabilize the above: type si32:"imut [&]"
    
    fn var_arg(...)
    fcn(1, _, _, 3)
    fcn(1, default, default, 3)
    ::@si32
    nc(_, _, _, .start := )
    nc(_, _, .start := 1)

    \"emeka daniel"u8 := 3
    \"emeka & daniel"p := 5
    "emeka"u8
    u8"emeka"
    '√∑'u8.info()
    u8'√∑'.info()

    \"daniel & esther's bread"u8.
    ``it shouldn't declare another literal when using as an identifer

    infer \"fn" := fn(type fn(infer)si32 fcn, infer a){ fcn(a); }
    infer temp := fn(type fn(infer)si32 fcn, infef a){ fcn(a); }
    infer \"t" := fn(infer arg1, infer arg2, type fn(infer, infer)void: "mut&" callback){ callback(arg1, arg2) }
    34343‚§∏
    4334344334049'‚§∏ //that shouldn't be possible
    234343434344340458309580

    110100000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111100000000000000000000000000‚§∏
    1001110101‚ÇÇ`si32

    1010''0010'''''''''''''''''''''''''''''1001010010100'101010010

    infer html := imbed html{ <p>Emeka Daniel</p> }
    infer c++ := imbed c++{ #include<iostream> int main(){ std::cout << "Hello world" << '\n'; } }
    infer c++ := imbed c++{ #include "io.h" auto main(){ io::cout.write_nl("Hello world"); } }
    infer nc := imbed nc{ use pkg (stdio, time) fn main(){ io::outf("Hello world { {type chrono::clock a(); a.now().\"time-zone"() } }"); } }
    infer html := "<html>Emeka = {122123232323‚ÇÅ‚ÇÜ}</html>"

    type si32:"[]" e;
    infer:"[]" e;

    abstract-values are mutable by default
    fcn(1,,2, 3,,4, 1.2,,3.4)
    fcn(1., _)

    match e{
        case(1, 2) give 2
        case(5) give 4
        case<si34> give 2
    }
    match f
    {
        case(23) io::out.setOutDevice(\"hp-printer-2902").("<html>emeka<html>")
        case(34) 34
    }
    *i.fcn()
    ++i.fcn()

    infer frac := type fraction(1, 2)

    1.2 + $(_v, 1.2, 1.2, 4.5, 6.7, 9.7, 9.0, 2.0)

    named_pt binary_exp, prefix_exp, postfix_exp {}
    named_st expression{type binary_exp, type prefix_exp, type postfix_exp}
    type darray<expression> exp_list
    (
        type expression(type binary_exp()),
        type expression(type binary_exp()),
        type expression(type prefix_exp()),
        type expression(type postfix_exp())
    )
    type darray<expression> exp_list
    (
        type binary_exp(),
        type binary_exp(),
        type prefix_exp(),
        type postfix_exp()
    )

    enum Expression{Binary_exp(), Postfix_exp(), Prefix_exp()}
    let exp_list := Vec::new(Expression::Binary_exp{}, Expression::Binary_exp{}, Expression::Postfix_exp{}, Expression::Prefix_exp{})
    
    type @expression::binary_exp()

    named_st expression{type binary_exp, type postfix_exp, type prefix_exp}
    named_st expression{type(binary_exp, postfix_exp, prefix_exp)}

    type_space expression{
        named_pt binary_exp, postfix_exp, prefix_exp{}
    }

    infer d_array := type d_array(type @expression::binary_exp())

    type si32 a := type si32(3)
    infer a := type si35(3)
    infer b := type dArray(type expression(type bExp()))
    infer c := type dArray<expression>(type bExp := 3, type uExp := 4)

    fn fcn(type si32 _, type si37 _){
        infer html := html"
        <html>
            <head>
                <p>Emeka Daniel</p>
            </head>
        </html>
        "

        infer sql := sql"
        from {\"generic-table"} get fancy
        "
    }

    fn assign(type u8str:"[]" me){
        me.1
        me.2
        me.3
        break(1)
        break(2)
    }
    assign(imut &type u8str(e))
    type si32 a := type si32(3)

    fcn(_i_, e, _d_, _f_, _j_, _l_o)
    fcn(i_, 3`sec)
    fcn(_v, 1, 3, 9, _v)

    b := 122222200000344309989900012344490002323‚§∏
'2334334'3454555

\iter
\"iter"
\rng := 34

while 2 == 9 : {}
for infer i := 2; i == 2; ++i: {}
iter i : (2, 9) {}
iter i : |mut vector| {}
iter i : |2~5| {}

    12343434233333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333123243222222223232.‚§∏
2323232948393940943040443093490939348988888888888888888888888888888888888833333333333333333333333333333333333333333333333333333333333333333333333390‚§∏
99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999900000900‚§∏
93400358099999999999999999999999999999999999999999999999999999999999943333333333333333333333333333333333333333333333333333333333333333333333333333332‚§∏
9000000000000000000000000000000000000000000000000000000000000000000000000099999999999999999999999988888888888888888888888888888888888888888888888888

    10110100111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000011111111111111111111111111111000000‚§∏
100000000000000000000000000000000001111111111111111111111111111111111111111110101100101001010101010100000000000000111111111111111100000001111101010‚§∏
000000000000000000000000111111111111110101010010111111100000100011111100010010101010000001010000000000000101010111111100000000000000000000011001001

    1234343'@-'3'3'4';

    type unicode uchar(10'fff‚ÇÅ‚ÇÜ)
    tcast<u32>(uchar)
    bcast<u32>(uchar)
    uchar|tcast<u32>
    u8""
    u32""
    u16""

    attribToExp(#[lineNumber::fn::call_site])
    #[runTime(false)] infer meta
    meta := intoExp(#[ast(true)])

    type achar a('√∑')
    '2' 'üëÄ' '‚§∏'

    type_space achar
    {
        fn _construct_(#[requires \"basic latin"] type literal::charWise::char ){}
        
        fn _construct_(#[requires \"si32"] type literal::charWise::char ){}

        typeof(asExp{#[literal::()]}) s

        a := '\(basic_latin[9])'
    }
    
    ``defining 2d arrays in nc
    infer \"2d uint array"

    \"2d uint array" := type farray(type farray(1, 2, 4, 0), type farray(1, 2, 3, 4), type farray(1, 2, 3, 4))

    type farray<farray> a(type farray(2), type farray(4), type farray(5))

    let arrayOfArrays: Array<Array<Int>> = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    int a[2][3] = {1, 2, 3, 4};
    - normal arrays in c++ cannot take arrays of different type than itself
    - std::arrays in c++ cannot take arrays of different size
    - my arrays can

    + Try accepting input from both (linux and window)s system, to test what encoding they use
    + There should be a platform agnostic way for file entry($root::user::document::learningCpp or $root::home::emeka::document::learningCpp)

    type atom a(type nucleus(type proton(46), _), type electron())
    while true:
    {
        printf("{atom}")
        use mod thread
        thread::sleep(12`sec)
        atom.energy_spike(3.4`kv)
    }
}

named_p red, blue, green{}
named_s color{type red, type blue, type green}

type_space color{
    fn current_variant_type(me){
        type plain_ptr<si32> \"si32*"
    }
}

named_pt color{type red x, type ui16 curr_i}

`{
    Circular referencing is not allowed....

    infer a = type u8str('a', ...[4])
    a + tcast<u8str>(3, .\"show pos sign?"=true)

    cast<`*type to*`>(`*type from*`)
    cast<si32>("345‚ÇÇ‚ÇÑ")
    type str(3, _, _, _)

    try type str(3, _, _, _)
    s"345" + handle type str(3, _)

    unichar x{"√∑", @encoding::utf32LE}
    try unistr c{file_data, @encoding::utf8} handle {}
    : The error is bundle together
    (lazy 2 * 3) + 3
    type file x => handle(error){}
    : Okay i now know how to bundle the error, by using a sumtype, but how do i enable efficient work with it?
    : And also, in single error situations, i already know how to propagate an error, but how do i propagate in multiple error scenarios

    prop divide(2, 3)
    prop (2/3)
    (2/3).unwarp()
    prop *ptr
    divide(2, 3) => (error) {}
    divide(2, 3) => |34|
    divide(2, 3) => |34| { log("something bad happened") }
    type str x(@encoding::utf8, file) => continue
    type ui64 x("2343@") => |0|;
    : This approach is too simplistic in practice, as it does not tell what the function gives therefore leaving a vunerablity to FFI
    : Instead of making a particular subset of types "error types", make it such that a sumtypes have a special set of syntaxes that only work
    for sumtypes that have two fields, one must be a generic field and the other either an enum or subtype of the error productType

    named_s result<type data, type \"subtypeof error or enum">: #constriant_error_sumtype(\"...") {...}
    match divide(2, 3): i, j, k{
        case<si45> i * 3
        case<dividebyzero> "divide by zero: sepcific{j}"|printf
    }
    try divide(2, 3) * 3
    divide(2, 3) => (error){ printf("divide by zero: specific {j}") }
    divide(2, 3) => |34|{}
    prop divide(2, 3) * 3
    give type result(3, &mut )
    : What of giving multiple error types in the same function
    {
        fn some_function() type result<?, ?>
        {
            prop (2/3) ``error: enum dividebyzero
            prop (2.0/3.0) ``error: enum errorneous{ dividebyzero, dividebynan, dividebyinf }
            prop type deserialize x(file, @format::json) ``named_p error {type jsonData}
        }
    }
    
    : How would inheritance be implemented so that extension typespaces aren't eager to allow inheritance
    {
        use type error
        use mixin error
        use interface error
        use pkg error
        use mod error
    }

    error::panic(s"emeka daniel {0, 1, 2}".insert(2, 4, 5))
    
    : There is no need for casting since constructors can be extended

    
    m_tokenString should change to m_token and it should be an object of type U8string_view, even line_content

    Encapsulation: information/data hiding
    Abstraction: is the hiding of unnecessary complexity
    Interface: is a shared communication point that allows different but functionality related entities to interact with those functionalities

    The advent of high-level abstractions should cost little to no overhead, and if it needs to, a compromise should provide

    [META PROGRAMMING: CCI - compiler communication interface]
    
    How i will type operations be treated when meta-programming?

    ranges: what is it?
    Type Concept: is an abstract idea that groups types into specific categories
    : is an abstract idea that groups types into specific categories, to operate on them in uison
    : an idea or mental image which corresponds to some distinct entity or class of entities, or to its essential features, or determines the
      application of a term (especially a predicate), and thus plays a part in the use of reason or language.
    a general interface?
    
    [progressive disclosure complexity]

    #type::is_eq(si32, #exp::getType(a))
    #{type si32 == #exp::getType(a)}
    #type(si32) == #type(si56)
    #place_id(4)

    #[type(si32)(is_mutable)]
    #type::is_mutable(type si32) #type::give(type si32) #expression::give(34) #expression::getType(2)

    ``how would type any and sum work? Because these are things that need to give/return types
    {
        type #type 
    }
    : Object declaration and expression has a conflict when parsing enclosed grouping stuff
    {
        type si32 [a, c, x]
        type si32 [a, c, v] [z, x, c, v]

        It is disqualified for object expression because it is meant to embody a singular entity like a literal
    }
    : Object_expression can be without initialization and functions can be without parenthesis
    : Designing LCI to have full language capability, treat types and other entities as data
    {
        : There should be a distinction between code and language-communication-subjects, like async, give or break should not be avialable in the
        LCI
        user-code
        language-code

        : Passing and giving of types should work how in nc? : try C++'s way of returning types
        : Returning of types would be handle in LCI but i don't even know how to implement that
    }
    : Varadic expression parameter entry is the only one that would be supported and not varadic type parameter entry
    {
        fn my(type #varadic _, type #varadic bat){}
    }
    : Think about how operator overloading and literal definition would go
    : Specialization and overloading think more: tcast<u8str>() is going to be overloaded not specialized
    : Casting is going to be fixed for only identifier overload resolution and enabling subtyping - both for non-references and references
    {
        subtypecast<>()
        resolve<>()
        refcast<>()
        : What of reference casting?
    }
    : A way to define and apply constraints
    : A way to store LCI in variables instead of on demand evaluation
    : How would the elispe [...] be used to auto complete expressions
    : Define the scope of what gets seen globally in a scope? [type, functions, aliases, namespaces, typespaces]
    : What of the semantics of discarding an abstract value?
    {
        To be discarded only through object declarations like: infer _ = 4
    }
    : Giving a value at the end of a function is not defined, so define it
    {
        : A distinction between giving values in blocks used in an expression vs used in an expression statement
        : When a block is used in an expression, the value given would be it's resultant value while when it is used as an expression statement,
        function or handle-error block, the value given would be the give value of the function
        : Blocks have the unique property of promoting the last expression, if any, in itself to be the give value of the block, to supress such
          promotion, a semicolonis used
        { ``the resultant value won't be (no type), but it would just ignore the last expression statement as it's give type
            give type date()
            34;
        }
        
        [if][while][for][iter][do][match][exp][jmp]
        
        : [else] would be defined for loops [for, iter and while]
        : Statements [if, while, for and iter] when used as a substatement must be done so in blocks

        : There should be a special give for constructing sumtypes
        {
            give type unamed_s<si32, d32fp>(56)
            give type unamed_s<si32, d32fp>(56.78)

            give : 34
            give : 34.5
            give :
        }
    }
    : Differentiate between using value-ignorant type void and the void for returning nothing during a function call
    {
        : Absence of type would be represented by the '!' symbol
        : While absence of value would be reprensted by 'type void'
        fn mave() ! {}
        type fn()! main()
        
        type void: &mut x
        !: &mut
    }
    : Strings and character parsing, how should it go?
    {
        type char x
        type u8str: & x
        
        : What of this byte and bytestream that i was going to incorprorate to be reading external data that may possibly have no representation
        like a non-encoded compressed file

        type byte x
        alias bytebuffer = type darray<byte>
        
        infer x = s"34456568898495849589849384384939349349348834" ``it would make sense for this to be allocated on the .data section
        infer x = s"2334334" ``it wouldn't make sense at all if this was allocated on the .data section
    }
    : Multiline string and integer parsing
    {
        : For strings
        {
            "
            emeka
            "
            same as: "emeka"

            and \ + (LF and CR) for mutliline unbreaking strings that also dosen't regard leading whitespace
        }
        : For multiline integers that dosen't regard leading whitespace
        {
            123243434\
            234334343\
            2343
        }
    }
    : Addition of U+D7 as the alternate multiplication operator
    : How should jump_statements be parsed?
    {
        (give [<expression>]) | (break|continue [<integer_number_literal>])
    }
    : Error Handling
    {
        Errors would be bundle with the item that can fail, there would be special syntax for error handling
        The special entities that would be in use: [try, prop, _propagate_, _panic_, =>]
        Example:
        {
            ``type char decoding a utf8 stream of bytes, which maybe be failiable in ways such as the ones in wikipedia
            try type char x(byte_stream, @encoding::utf8) ``try and fail if something errorneous is found

            prop type char x(byte_stream, @encoding::utf8) ``propagate the error if it was found

            type char x(byte_stream, @encoding::utf8) => (err) {} ``handle the error if it was found
            
            type char x(byte_stream, @encoding::utf8) => |type char('ÔøΩ')| ``handle the error by suggesting an alternate value of the same type

            type char x(byte_stream, @encoding::utf8) => |type char('ÔøΩ')| {} ``handle the error by suggesting an alternate value of the same type and still doing some extra stuff like logging or reporting it

            type char x(byte_stream, @encoding::utf8) => (err) |err.alternate_value()| ``handle the error by suggesting an alternate value from the error object of the same type

            type char x(byte_stream, @encoding::utf8) => (err) |err.alternate_value()| {} ``handle the error by suggesting an alternate value from the error object of the same type and doing some extra stuff

            ``If multiple errors were found it can be handle by the doing the following

            type char x(byte_stream, @encoding::utf8) => (err1, err2) {}, {}

            type char x(byte_stream, @encoding::utf8) => |type char('ÔøΩ')|

            type char x(byte_stream, @encoding::utf8) => |type char('ÔøΩ'), type char('Î∞õ')|

            : When an alternate value is suggested, specification of give would not be allowed
            : The error syntax is specific to binary sumtypes whoose first or-field is a non sumtype and second or-field that is of a different type than the first
        }
    }
    : infer's semantics around object-declaration is still wonky - solved
    {
        infer [a, b, c] = [mut [1, 2], imut 4]
        infer [a: mut, b, c] = [1, 2, 3]
        
        : infer can only use indirect construction
    }
    : Think more about moving by default, what of integers which can be copied without consequence?
    {
        stealing instead of moving would be better and stealing can only be done for pointers that are of heap origin

        : Only [copy] would be added
        : Since moving is the default indirect constructor to use when it is specified in a type, adding [move] isn't necessary

        : types that have a steal constructor are chosen as the default constructor for indirect constructor
        : on-demand product and sum types cannot participate in stealing and cannot have items of their own
    }
    {
        : [divisor * quotient + remainder = dividend]
        : Addition of [memoryof] operator
        : [$] is now the dereference operator
        : New syntax of pointers [type si32: *], [type si32: *mut], [type si32: &*] and [type si32: &*mut]
        : For integers and their hardware overflow property, they would panic if encountered
        : Integer divide by zero would panic if encountered
        : [_rl_] to be used for relational and logical expressions
        : [_v_] to be used for delimiting varadic arguments
        : [subcast<>()] casting a subtype to a supertype and [supercast<>()] casting a supertype to a subtype
        {
            A    A   B
            ‚Üì     ‚Üò ‚Üô
            B      C
            ‚Üì
            C
        }
        
        {
            2.checked_add(0)
            2.unchecked_add(0)
            2.precision_add(0)
            2.saturate_add(0)
            : unsigned subtraction would be a safe subtraction that prevents overflow
        }
        {
            type arbitrary_si x
            type arbitary_ui x
        }
        : Abstract and concrete values have wonky semantics
        {
            2 = 3
            "emeka" = 3
        }
        : Operator overloading solid semantics must be defined
        : Solidify the semantics that would make the primitive string type(u8str) only be avialable as a reference
        : [iter] would be merged with [for]
        : Discuss enums at length i.e how exactly they would be used in my language

        type si32: &*mut = &mut addressof x
        type si32: &*mut(x)
        type si32: *mut
        try $ptr
        ptr->
        infer x = malloc(#type(si1024).sizeof(), 4) => (err) |!: *mut ()|
        
        
        s"3 " + 'üëÖ' + '0'
        ('3'+'4')
        '3'+'üëÄ'+'üëÇ'
        type u8str:& x

        fn fcn() type si32 ~> #{} {}
        
        type sd32fp [x, c]
        named_p x { #private type [si32, si45, si82] x }
        
        #access::private
        typespace x
        {
            fn main(){}
        }

        type mem x(type vector())
        type mem y(type vector())
        
        x xor x

        fn \"external data from file"(type str: & x){}
        try (type sui32(2) * 23)

        use pkg std::[io, string, unicode::[], regex_all, nc_regex, regex]

        type [lang::dart, lang::cpp, lang::c, lang::python, lang::nclang, lang::bython, lang::rust] x
        type lang::zig x
        type lang::go x
        type lang::swift x
        type lang::java x
        lang::{dart, cpp, c, python, nclang, bython, rust}

        resolve<lang::java>(x).function_def("fn pub static main(Strings[] args){ System::println("Hello World!") }")
        resolve<lang::java>(x).class(main_func, type type_alias())
        resolve<lang::java>(x).compile().run()

        fn fcn<type [t, t2]>(type [iterator, mass][it, kg]) :: #{
            if iterator.fromTheSameObject(): give
            if not _windows_
            give ?
            ?: &mut
        } {}
        #[comptime, directive(), {}, {}]
        
        
        : The LCI that has block as it's focus would be used for type manipulation
        : The focused block is only allowed to give a boolean expression that would be used as a constraint when used in certain places
        : The LCI square brace focus would be used for mutilple LCI focuses expect the sqaure brace focus itself
        : The LCI parenthesis brace focus would be used for assignment of other LCI focuses

        : How to store boolean values to be used as storage for defining of complex constraints

        #(emeka) = #[comptime, {false}, lifetime_promotion]
        : LCI functions
        {
            - extend_lifetime
            - private
            - readonly
            
            - directives(dir namespace)
            {
                - private
                - readonly
                - public
                - extend_lifetime
                - callFirst
                - callLast
                - explain_code

                - static
                - if_static_eligble
                - is_static
            }
            - marking
            {
                - <>
            }
            - functions(fcn namespace)
            {
                - getLineNumber
                - getStartColumn
                - getEndColumn
                - getColumnPair
                - getCallSiteLineNumber
                - getCallSiteStartColumn
                - getCallSiteEndColumn
                - getCallSiteColumnPair
                - type_hash
                - typename
                - explain_code
            }
            - type(ty namespace)
            {
                - exp
                - decay
                - \"rm &"
                - \"rm *"
                - rmRef
                - rmPtr
                - \"rm &"
            }
            
            fn priv(type si32 x = #fcn::getLineNumber()){}
            priv()
            try api_call()
            apicall() => (err)
            {
                log::log(#fcn::getLineNumber())
            }
            
            #<e> match apicall: i
            {
                case<error>{
                    #fcn::getLineNumber(<e>)
                }
            }
        }
        
        #private named_pt Daniel { #public type }

        {
            : variadic argument entry
            : Would a type parameter match a function type?
            : Think more about the for loop for ranges semantics
            {
                for i : |&mut x| {}
                for &i : x print(4)
                //and also this:
                for i, j, k : ([1, 2, 3], 4, 5) {}
            }
            : Format for variadic entry in nc
            {
                fn integer_galore(type si32 x...)!;
                fn anything_galore<type t...>(type t x...)!;
            }
            : [...] would be the spread operator that works for types dependant on type parameters and on types that have the function operator overloaded for them that takes an integer argument
            : [_vself_] would be introduced to deal with self binary operations
            : Having things like [x(1) and .len]

            
            
            
            
            
            fn #op()(&me, type si32 x)
            {
                #if_comptime_eligble
                if x < me.len :
                {
                    if is_comptime :
                    #comptime panic(1, 2, 3)
                }
                panic(#exp::lineNumber_callsite)
            }

            for infer sum = 3`si90; i : |mut x| sum += x(i)
            for i, j : ((0, 2), 3, (2, 3), #op <, (#op *=, #op +=)) {}
            
            #dir::shallow_explain lad(_, _, _, _, _, _, _, 6)
            #dir::explain_comprehensive
            #dir::explain(true) lad()
            #dir::explain(false) lad()
            
            
            fn march<type ?>(type #ty::variadic<?> x)
            {
                puts(x.expand())
                
                print(x)
                _ncputs_(type bytestream x(1, 2, 4, 5, 6, 7, 8, 9, 3).getData())
            }

            typespace darrat<type t>
            {
                fn _construct_(type char x...)
                {
                    push(x)...

                    for i : |x| push(i)
                    for i : (.end= x.len) push(x(i))

                    x... * [2, 3, 4, 5]
                    
                    #dir::comptime
                    for i : |&mut x|
                    {}

                    _expand_(x, push)
                    push(1, 2, 3, x, 3)
                }
            }
            
            : How would something like this be called in nc?
            {
                pass(somefunction(args)...)
                somefunc()[3, 4, 5, 6, 5]
            }

            : How would i work with an attribute like i would an expression?

            : How would something like jthread work in my language
            {
                type concurrency::jthread x(fcn, (function args)?)
            }
            : What of this [ fcn(&arg...) ]

            : Reality of what a type like farray and darray
            {
                type farray<si32, si32, si34, si90>
                type darray<si32, si8, si34, si89>
                => if it's 

                similar to:
                type unamed_p<si83, si89, si90>
                which it is something i don't want

                There is a difference when a type is dependant on type parameters in the type itself than in the typespace, so
                named_p farray<type t> { type [t: *,  size] x }

                t.areFunctionArgs(args...)
                std::jthread x(fcn, 1, 2, 3, 4)

                _ty(e...).varadic_size()
            }
            
            type unamed_p<si32, si34, si8, si90>
            (...).mustBeFunctionArgs(fn(...)?)
            e := 34
            _ty_(#ty::expType(z)).decay()

            : use aliases for types that
            : [!] should not be aliased
            : No more void:& for [!]

            alias functionType = type fn()!;
            : Wouldn't [any] be more adept with the function that this [!: ?] has
            
            type any x = 2 --> is it syntacticly equalivant to [void*] in c++
            
            
            
            : What of when deducing expression types
            {
                : There is to be no conflict what so ever
                : If the expression type already has qualifiers, then another may not used on it unless the expression type is decayed

                type s::decay<t> x

                type #ty::exp(23) x
                _ty(#ty::decay<t>) == t
                _ty(decay<t>) == si32
                
                alias decay<t> = #ty::decay<t>
            }
            : How to use default implementations in a trait in rust? like add
        }
        
        {
            std::uint32_t count{};
            for (size_t i = formerFilePos; m_isEndofFile? i <= m_filePosition : i < m_filePosition; ++i)
            ++count;

            m_tokenString.assign(m_fileBuffer, formerFilePos, count);
        }
        {
            type ui32 count()
            iter i : (formerFilePos, void)
            {
                ++count
                if m_isEndofFile? (i <= m_filePosition : i < m_filePosition):
                break
            }
        }
        
        [monomorphic code, polymorphic code]
        
        type ? [len, ]
        type mixin(default_assignment) x
        type interface(soliders) x
        type subtype(massive) x
    }
    : Problems concerning LCI
    {
        if i can do this:
        {
            named_p vector<type t>{}
            typespace vector<type t>
            {
                fn flip(me)type si8 `:
                #{
                    if t == bool:
                }
                {}
                filesystem::copy(path, dest_path, _) => {}
            }
            named_p
            {
                #private:
                type si32 x: mut
                #readonly:
                ronly:
                type si67 c: mut
            }
        }
    }
    : match statement has additional syntax
    {
        match type si34 z; x : i {}
        match type si34 z; x : [i, _ k] {}
    }
    : A bitwise shift operator
    {
        8 >>> type pair(2, .base = 4)
        8 >> 2
        8 >> type pair(2, .base = 8)
    }
    : No more do-while but just a do-loop similar to rust's loop
    {
        do: #compileTime type si8 x = 4;
        {
            alias size = x;
            type heap<si1024> x(size, .init= 34)
        }
    }
    : Abstract values and concrete values are equally valid in cases of referencing
    : Also only unused abstarct values are errored against
    : Warn against object-declarations inside loop blocks, because of repitition is bad
    : Strong and weak typing and static and dynamic typing
    : Semantic unified definition of operator overloading
    {
        generic code
        - static and dynamic dispatch
        
        we can also have constraints on them, that can define semantic and syntax restrictions on them

        OOP concepts
        1. Encapsulation
        2. Abstraction
        3. Inheritance
           - Polymorphisim

        NC concept
        #implemts(#op(+, -, /, %)) type any x

        x := 3
        x * 2
        #def(type t, type t)
        {
            if t == t:
        }

        type any<> x(@constraint::arithmetic)
        type mixin() x
        type interface() x
        type subType() x

        : a form of dynamic typing under polymorphisim
        : I have defined an abstract idea of heterogenous type entry

        type vec<any<#constraintarithmetic>> x(11, 3.4, 9.0, 4.3, 67.2)
        x[0] + 1
        x[1] * 2.9 = ?

        type mixin(default_addition)

        mixin default_arithmetic{
            fn #operator(+, -, /, %, *)(&me, &other){
                if #operator_arg == operator+:
                me + other
                else if #operator_arg == operator-:
                me - other
                else if #operator_arg == operator/:
                me / other
                else if #operator_arg == operator%:
                me % other
                else if #operator_arg == operator*:
                me * other
            }
        }

        : Regarding not being able to refer to type members for constructs like aliasing and default parameter entry, i don't want that, i want my
        language to be more flexible than that
        {
            fn fcn(&me, type os::si end_column = me.end_column)
            {}

            fcn()
            a.fcn(s = a.end_column)
        }
        
        emulate through sumTypes
        composition and interfaces
        emulate through interface inheritance
        mixins
        Polymorphisim: dynamic dispatch
        extensibility of enums
    }
    : Reverse the doc and discard comment syntax
    {
        `|em|`
        `|emeka daniel|`
        `{emeka daniel}`

        `*emeka daniel*`
        ``emeka daniel
    }
    : There cannot not be more than two references to the same data at a time
    : Change type_space and name_space to typespace and namespace
    : What are enums really?
    : Make a table class
    : Why not call nc-objects data?
    : code-reuse: interface, mixins and inheritance
    : What of this total ordering operator: (3 <=> 2) == @ordering::equal
    {
        - what would i call a code-resue that provides both functionalities of an interface and mixin
        - what of whether they can redefine functionalities
        - which ones would get to reuse member state/data

        interfaces only take other interfaces for code reuse
        mixins are the only method of code reuse whoose functions cannot be redefined
        interface should be soley different from a type?
        Mixins would not have constructors
        - what of implementing functionality similar to member data/objects ?
        {
            mixin c
            {
                fn mark(&me) type @me::item
                {
                    printf("{me.get}")
                }
            }
            #private[module]:
            #readonly[package]:

            type mixin(c) b(/*imaginary that has member data get*/i )

            b.get
            - accessing nc-objects through mixins must have the same access-specifier throughout all mixed-in types

            use mixin show
        }
        Would mixin function have their own scope by just being mixin functions alone?

        @show
        mixin show::fcn()
        interface show::fcn()

        data container

        interface
        typespace si32{
            fn call(){}
        }
        mixin show {}
        interface show {}
        typespace show {}

        type mixin(show, json) x
        type interface()

        include mixin show

        mixin show
        {
            fn show(me)
            {
                \\no diagnostic would be gotten here
            }
        }

        type any<?> show
        show := 3
        show::c
        
        infer x = cast<fn(pid, raw_ptr<void>)>()

        mixin default_logical_operations{
            fn #operator==(&mut me)
            {
                
            }
        }
    }
    : [infer] being superfulous
    {
        infer x
        x := 'n'
        x<si4> := 'b'
        x<json> := 'cool'

        infer [x, x, x, x]
    }

    
    The creator of the language has root previleges

    {
        ``I wrote this type of code alot in the lexer
        while true:
        {
            if `{main condition}` : {}
            else {}
        }
        
        ``while i could have just done this
        do
        {
            ...
        } while `{main condition}`;
        
        ``else is a different concept than the above, it evaluates when a loop's condition was found to be false initial
        ``check what python uses it for
        ``check your code in the lexer to figure out how i would replace the redundant [while true] code

        do
        {

        }
    }
    ``Define what and what gets copied, is it everything?

    ``Dealing with type parameters and how it can be used
    ``Dealing with overloading of identifiers
    ``Dealing with function semantics that enforces only one value
    ``Dealing with initialization semantics
    {
        - A good way to support dynamic entry of heterogenous types
        - All identifiers of type associated declarations would have an optional type parameter entry
        
        : Looking at what to allow and overall defining it to be less complex as possible

        : Overloading is the redefinition of identifer in the same name_space scope
          - Function and object identifiers are in the same category
          - Name_space is in it's own category
          - Data type is in it's own category
          - Alias is identifer dependant: (Data type Identifier, Name_space Identifier, Expression)
        
        : Function identifiers can be overloaded by the following -
          + The expression parameter number, i.e it excepts that the expression parameter number be different across overloads
          + If the expression parameter number is the same, the type of the expression parameter
          + The type parameter, only if it maintains the same number of type parameters, makes use of a constraint and/or obeys the two rules above

        fn dac(type [si1, si2, si3] _){} ‚úî
        fn dac(type si1){} ‚úî
        fn dac(type si2){} ‚úî
        fn dac<type t1, type t2>(type [t1, t2] _){} ‚úî
        fn dac<type t1, type t2>(){} ‚úî
        fn dac<type t1, type t2>:
        #
        {
            if #type(t2) != #arithmetic_type or #type(t1) != #arithmetic_type: #go
            if r_l(#arithmetic_type, #operator(=))(#type(t1), #type(t2)): {}
        }(){} ‚úî

        r_l(2, #operator(=), $(2, 3, 4, 5, 6, 0))
        r_l(2, #operator(=, or), $(2, 3, 4, 5, 6, 0))
        r_l(2, #op =, #op or)
        r_l(2, #op(and, or))(e, r, t, l, type manup(4), type twoup(), type threeup = a)

        : Default expression argument entry
          + '_' is overloaded in meaning for use as a placeholder identifier for default argument entry
        
        : Default type argument entry
          + Type arguments can be deduced from expression arguments
          + If all the default type parameters has been all deduced, the type argument entry angle braces '<' '>' maybe ommited
          + Allows for implicit default entry

        : Type parameters can be deduced from expression arguments, and when deduced, behaves like the type parameter has been give a default
        argument, and therefore gets to utilize default type arguments rules
        
        fn dac<type [t, t2]>(type t a){}
        dac<_, si4>(1`si3)
        fn dac<type [t, t2]>(type t a = 1`si3){}
        dac<_, si4>()
        fn dac<type [t, t2] = $(si3,)>(type t a = 1`si3){}
        dac<_, si4>()
        
        fcn(vv, 2, 3, 4, 5, 6, vv)

        : Specification of default arguments for both type and expression parameters are unintuitive and should be warned against
        fn dac<type t1 = si3>(type t1 x = 0`i3){}

        : Function identifer overload call resolution
          + Between the ones with type parameters and the ones without, choose the more concrete overload
          + Between the ones with implict default argument entry and the ones without, choose the one without an implicit
            default argument entry

        : Function/object identifer overload resolution without type parameters
          + Must be of a different type and for resolution, cast to the type of the identifer they want
        
        : Function/object identifer overload resolution with type parameters
          + Simply make the type arguments entry explicit

        : Function/object identifer overload resolution with and without type parameters
          + Simply follow the rule for type parameters or the rule for the one without

        : Overloading a function/object identifer in a parent block scope across it's child scopes, colloquially known as overshadowing
          + Follows the same rule as Function and object identifer overload

        : Overloading a function/object identifer in a parent name_space scope across it's child scopes
          + Follows the already defined function/object overloading rules
          + If it is overloaded across name_space scope, and it is needed to be called in a child scope, explicit identifer qualification is required

        cast<fn(si3, si7, bool, bool)u8str>(cast<u8str, si3>) ``complier should error as this is redundant
        cast<fn(si3, si7, bool, bool)u8str>(cast) ``preferring one over the other, it is not allowed to prefer one over the other
        cast<u8str, si3>
        type si34 a<type T, type U> = {}
        cast<si32, si3>(a)

        fn cast<type t, type t2>(){}
        fn cast<type t, type t2>(type si32 _){}
        fn cast<type t, type t2>(type si8 _, type si6 _){}
        fn cast<type t, type t2>(){ #constraint(t, t2) }

        cast<u8str>(1, _, _)
        fn dac() infer{ emeka daniel }
        fn dac() type si32{ }

        fn dac();

        fn dac(type (si34, si37) _ = $(, 23`si37)){}
        fn dac(type si32 ){}
        
        fn dac(type si32 _ = 34){}
        fn dac(){}

        dac(_)
        tcast<fn(si32)>(dac)()

        fn dac(){}
        fn dac(type si3 _){}

        infer a = tcast<fn(si3)void>(dac)
        infer a = tcast<fn()void>(dac)

        ``overload resolution
        tcast<fn(si3)void>(a)()

        ``no need for overload resolution here, because the type is explicit
        type fn(si3)void b = dac
        
        : What of identifer overload amongnst types ? during type definition(type parameters, named_pt, named_st, type aliases)
          + For type parameters, redefinition of an already type identifer is not allowed and would be warned against
          + For named_pt and named_st,
        ______________________________________________________________________________________________________________________________
        
        : <arg> needs to permit an empty argument like so: $(, 3)
        : <arg> does not give any value, it is just parsed as an expression
        
        : Initialization and type grouping is currently messy, fix it

        : I should disallowed for <object_exp>s right?

        : No more comma expression and parenthesis with values seperated by comma is now <arg>
        : <arg> only works for multiple values, meaning types that take only one argument or makes use of implicit default entry are not allowed
        
        type si8 a(type si8())
        type bark x(2.3)
        type(sack, bake, bark)(a, b, c)((1, 2, 3), (1, 2, 5), (0, 9, 4))
        
        for infer (i, j, n)(mut (2, 3), vec.size()); i < n; {++i ++j}:
        none
        
        infer(a, b, c) = $(type (si8, si8, si8)())
        infer (a, b, c) = type(si8, si8, si8)(type si8(), type si8(), type si8())
        infer (a, b, c) = $(type si8(), type si8(), type si8())
        infer (a, b, c) = type(si8, si8, si8)(23, 45, 90)
        a + ...
        ... + a
        a + ...(2)
        +a...
        a... + a...
        fcn(a + ...)
        
        type (si8, si8, si8)(a, b, c) = .{}
        type(si8, si6, si9)(a, b, c)|fcn
        (a, b, c)|fcn

        type si32 a = type(si32)()
        type si32 a = ()
        type math::vector a = (12, 90)
        infer vec = type math::vector
        
        : How would i treat 'infer' in all this?

        infer(a, b, c) = type(si8, si8, si8)(1, 2, 4)
        infer(a, b, c) = $(type si8(), type si8(), type si8())

        type(si32, si33)(a, b)(23, 89)
        infer(a, b)(23`si32, 89`si33)

        type (si34, si37) _ = $(, 23`si37)

        fcn(type si32 := 3, type si37 := 45343434232323)
        fcn(type si32 = 3, type si37 = 4565923tr8839hhn‚ÇÇ‚Çâ)
        fcn(type(si32, si37)(a, b)(, type si37()))

        type si32 a type si32 b type si32 c
        type si32 (a, b, c)
        type (si32, si32, si32)(a, b, c)
        infer (a, b, c)(type si32(_, _, _)) -> infer (a, b, c) = type (si32, si37, si95)()

        give type(si32, si37, si33)()
        
        : Think about this named_st P{type (c, a)}
        : Grouping syntax for expressions too
        
        (a, b) = (10, 9)
        (a, b) + (10, 9)
        -(a, b)
        *(a, b) =- (10, 9)
        (a, b) = (g, h) = (k, l)
        (a, b) + (g, h) * (l, k)
        
        infer r1 = a + g
        infer r2 = b + h
        r1 * l
        r2 * k

        b = (x.1, x.2) * (y.1, y.2) + a ``what does it return ??
        type si32(a, b) = (x.1, x.2) * (y.1, y.2) + a
        #treat_as_exp_unit
        type unamed_pt _ = (x.1, x.2) * (y.1, ) + l
        
        : Grouping parenthesis would have a different meaning for piping

        : What about discarding of give values? Because assignment operators discard values all the time and it is even used to discard values
        _ = fcn()
        _ = fcn()
        #domant infer a = c;
        infer _ = c;
        #exp::unused fcn()

        : I want type qualifiers to parse for [mut, imut and &] instead of string

        type si32: mut& e
        type si3: & h

        + Expression parameters take precedence over type parameters when resolving function calls
        + Only the ignore identifer is alllowed to be overload without restriction

        named_pt string{type(heap_ptr, si32)(data, size)}

        type_space string
        {
            alias get_size = me.size()
            
            #fn::inline
            fn get_size(me){ me.size }

            alias get_len = get_size
        }
        : Aliases would alias types with qualifiers
        {
            alias mutable_si32 = type si32: mut ``[SEMANTIC ERROR]
            
            type mutable_si32 _
        }

        : Something interesting
        {
            #{ #module_space_objects_types.(#mutable)? (#thread_owned : #nothing)  }:

            #thread_owned:

            type si3: mut xc = {
                \"c is the best"::custom_allocator((4, 2) / #type<si3>::size())
            }
        }

        : Can type parameter entry braces be used for distinguish when resolving overloads??

        fcn<>(1, 2)

        : Arithmetic, logical and relational operators must take the same type
        
        type time::month(2) * (type time::year(1) | tcast<type time::month, type time::year>)

        : Piping cannot perform any type parameter inferrence, the example above proves it

        : Does 'infer' require a type arguments when used in a function too??

        : 'infer' specification is the same as type parameter entry but without the type identifier
        
        : What of that confusing thing that C++ does when resolving templates
        {
            template<typename T>
            int fcn(T& x)
            {
                [T] would contain only the type,
                [x] would be an object with the full type
            }
        }

        {
            ‚ù∞emeka daniel‚ù±

            encolsed grouping for expressions is valid only in contexts where it is also valid in normal unenclosed/expanded code
            i.e
            type gender(type [male, female]) ``is valid
            ``but this:
            type [male, female]|f ``is not valid
            
            type si32[a, b, c] = {
                type si32[a, c, v] [type[si32, si90, si32][a, v, c]]
            }

            Construction/Initialization
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            Is the process when an object is created to be valid for it's type and nothing else

            Holds the post-condition that after construction - and assuming there is not alteration of control flow -, the object is valid
            Holds the invariant that states an object must be constructed before it's use

            Types of construction
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            1. Direct(function call like): takes the argument for construction/initialization of the object and nothing else - not even the object
               itself
            2. Indirect(assignment like): takes an already constructed object of the same type and nothing else

            Elision of already constructed objects from using the move/copy constructors are turned on by default
            #optimizations::elision(false) ``insightful

            [Delayed construction/initialization]

            [(x, m), (y, p), (l, h)]|[fn1, fn2, fn3]
            type[si32, si4, si90]
            type(si32, si4, si90)
            [x, [y, [z, [c, g]]]] + [a, [b, c]]
            (x, (y, (z, (c, g)))) + (a, (b, c))

            type [si32, si8] a = [type si32(), type si8()]
            type [si32, si8] a()
            type [si32, si8] a[(), (2, 3)]
            type [si32, si8] a()
            type [si32, si8] a = a
            a + [a, b, n]
            type [si32][a, b, c]
            [(2, 3), (4, 5)]|[f, c]
            [(3, 4), (0, 9)]|[[f, c], g]

            Groupings
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            Is a language feature that treats certain entities as a single unit. It's main inclusion to the language is to eliminate unnecessary
            typing that sometimes leads to code verbosity and to add a more high-level touch to the language. It embodies the write less while
            doing so much narrative.
            Anything that can expand to ordinary valid language syntax is not allowed.

            Types of groupings
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            1. unclosed-grouping: used for declaration identifiers other than those for objects
            2. enclosed-grouping: used for certain part items(types and object declaration identifiers) and expression

            Unclosed-grouping
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            ...

            Enclosed-grouping
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            The entities used for enclosure are the left and right square braces '[' ']'.
            Unlike an unclosed-grouping-group, an enclosed-grouping can be acted upon, meaning it can be scaled by another enclosed-group,
            unenclosed-group or acceptable single-like-entity - i.e an expression or object-declaration-identifier.
            The defined semantics for enclosed-groupings are that of expansion. The expansion follows a pre-condition that states that it's
            application must be for entities that already can implement the expansions without enclosed-groupings.
            The above statement would be futher explained
            
            example:
            type si32 [a, b, c]
            type [si32, d32fp]
            a * [b, c]

            The contents of an enclosed group must be entites separated by a comma. So singletons like this [x] do not qualfiy as an enclosed-
            group

            [NOTE]: an enclosed-grouping can also be callled <type>|<object-declaration-identifiers>|expression> unit

            Levels of an enclosed-grouping:
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            Levels of an enclosed-groupings essentially means the nesting levels of a enclosed-grouping, just like how blocks can be nested
            example:
            [a, [l, o]]
            ‚îî‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚î¨‚îÄ‚îº‚îò
                ‚îÇ  1 ‚îÇ
                ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
                   2
            
            [x, [c, [b, [k, l]]]]
            ‚îî‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚î¨‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îº‚îº‚îò
                ‚îÇ 1 ‚îÇ   ‚îÇ    ‚îÇ‚îÇ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚î¨‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îº‚îò
                    ‚îÇ 2 ‚îÇ    ‚îÇ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚î¨‚îÄ‚îÄ‚îº‚îò
                        ‚îÇ 3  ‚îÇ
                        ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
                           4
            The language syntax permits only an expression to have mutiple levels of a enclosed-grouping

            Enclosed-grouping follows two basic rules for it's use:
            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            1. When acted upon, both sides must have full coverage of each other or to be more succint, all valid entities of one side must have a
            corresponding valid entity to act on the other side
            
            FOR TYPE AND OBJECT-DECLARATION-IDENTIFIERS:
            type si32 [a, b, c] ‚úî
            type [si32, si45, si80] [d, e, f] ‚úî
            type [si32, si32] [a, k, g] ‚§¨

            [b, a, c] = v ‚úî
            [b, a, c] - [v, g, n] ‚úî
            {
                (‚úî) b - v
                (‚úî) a - g
                (‚úî) c - n
            }
            [b, a, c] + [f, j] ‚§¨
            {
                (‚úî) b + f
                (‚úî) a + j
                [-] c + ?
            }
            [x, [y, [z, [c, g]]]] - [a, [b, c]] ‚úî
            {
                [*] x - a
                [*] [y, [z, [c, g]]] - [b, c]
                {
                    [*] y - b
                    [*] [z, [c, g]] - c
                    {
                        [z - c, [c - c, g - c]]
                    }
                }
            }
            [x, [y, [z, [c, g]]]] - [a, [b, c], o] ‚§¨
            {
                [*] x - a
                [*] [y, [z, [c, g]]] - [b, c]
                {
                    [*] y - b
                    [*] [z, [c, g]] - c
                    {
                        [z - c, [c - c, g - c]]
                    }
                }
                [-] o - ? ``this the problem
            }
            [x, [y, [z, [c, g]]]] - [a, [b, c, m]] ‚§¨
            {
                [*] x - a
                [*] [y, [z, [c, g]]] - [b, c, m]
                {
                    [*] y - b
                    [*] [z, [c, g]] - c
                    {
                        [z - c, [c - c, g - c]]
                    }
                    [-] m - ? ``dosen't offer full coverage
                }
            }

            2. It must have defined language semantics

            FOR TYPE:
            The defined semantics for it's use in types are that of expansion. The expansion is only defined for situations that can already be
            implemented without parenthesis grouping

            example:
            - alias myInt, bestReal = type [si32, d32fp]
            {
                ``The above uses both type of groupings i.e unclosed-grouping for the alias identifiers and enclosed-grouping for the type
                ``It is valid as the expansion can already be implemented without parenthesis grouping

                alias myInt = type si32
                alias bestReal = type d32fp
            }
            - named_st arithmetic{ type [si32, si64, si128, b32fp, d32fp] }
            {
                ``The above is also valid because the expansion can already be implemented without parenthesis grouping
                named_st arithmetic{ type si32, type si64, type si128, type b32fp, type d32fp }
            }
            - fn fcn() type (si32, si8)
            {
                ``The above is not valid because the expansion cannot be implemented without parenthesis grouping
                fn fcn() type si32 type si8 ``SYNTAX ERROR: reserved identifier 'type' found at unexpected location
            }

            FOR OBJECT-DECLARATION-IDENTIFIERS:
            The defined semantics for it's use in object-declaration-identifiers are that of expansion too. The expansion is only defined for
            situations that can already be implemented without parenthesis grouping, but this pre-condition is always true for enclosed-grouping
            on object-declaration-identifiers

            example:
            - type si32 (a, b, c)
            {
                type si32 a
                type si32 b
                type si32 c
            }
            
            FOR EXPRESSIONS:
            The defined semantics for it's use in expressions is more complicated than the others.
            [NOTE] Expressions allow for multiple levels

            operators:
            - It performs ordered expression wise evaluation and gives a enclosed-grouping of the results of the operation
            {
                rl(3, ##op(=, and))
                1~2~3

                ``[->] denotes the equivalent operation
                d.*fcn()

                [[a, b, c].[f, g, l]]() -> something like this should not be allowed, because enclosed grouping requires multiple entity stuff

                ([a, b, c].[f, g, l])()             -> [(a.f)(), (b.g)(), (c.l)()]
                [a, b, c].[f(), g(), l()]           -> [a.(f()), b.(g()), c.(l())]
                *[a, b].[f, g]()                    -> [[*a].[f()], [*b].[g()]]
                *[a, b, c] += [n, m, c]             -> [*a += n, *b += m, *c += c]
                -[a, b]                             -> [-a, -b]
                b = [1, 2]                          -> [b = 1, b = 2]
                [a, b] = [c, d]                     -> [a = c, b = d]
                [a, b] - 1.9                        -> [a - 1.9, b - 1.9]
                [a, b, c] + [d, e, f]               -> [a + d, b + e, c + f]
                [a, c] * [b, x] + [e, g]            -> [a * b + e, c * x + g]
                [[c, v], p] =/ [k, l]               -> [[c /= k, v =/ k], p =/ l] ``lhs has a two level enclosed-grouping
                [x, [y, [z, v]]] - [a, [b, c]]      -> [x - a, [y - b, [z - c, v - c]]] ``lhs has a three level enclosed-grouping
                [x, [y, [z, [c, g]]]] + [a, [b, c]] -> [x + a, [y + b, [z + c, [c + c, g + c]]]] ``lhs has a four level enclosed-grouping
                [x, y, v]|fcn                       -> [x|fcn, y|fcn, v|fcn]
                [(a, b, c), p]|[fcn1, fcn2]         -> [(a, b, c)|fcn1, p|fcn2]
                
                (x, y, b) is called an multiple-pipe-exp-output

                ``example for swapping objects using an intermediate object as a store
                ``The two objects to swap are [a, b]
                ``The temporary object that stores an intermediate object value is [c]
                [c, a, b] = [a, b, c]               -> [c = a, a = b, b = c]
            }
            others:
            - It only expands when used as args in the call and pipe operator and it expands by the total number of entities in the resultant
            enclosed-grouping
            {
                fcn(x, [y, z])              -> fcn(x, y, z)
                fcn([a, [b, [c, [e, f]]]])  -> fcn(a, b, c, e, f) ``the compiler should warn about this being irrelevant
                fcn([m, n] + [s, c])        -> fcn(m + s, n + c)
                (a, [c, b])|fcn             -> (a, c, b)|fcn
            }
            - For object exps, the semantics are undefined by the language, and therefore not to be used with it

            MORE INFO:
            when used in evaluation expressions, to leave an expression unevaluated can be done just by not specifying anything after the comma
            [a, , b] + [x, y, c] -> [a + x, y `{unevaluated}`, b + c]
            This is not particularly useful, only in cases where a argument entry is need for an evaluation before passing:
            {
                fn pass_something(type si32 a, type b32fp c, type si32 b){ _ = a _ = c _ = b `{would error because '_' cannot be used}` }

                fn main()
                {
                    infer [a, b, c] = [type si32(34), type b32fp(), type si32(56)]
                    pass_something([].[precison_mul, , precison_mul]())
                    pass_something([a, b, c] * [a, ,c])
                    pass_something(([a, b, c].[precison_mul, ,precison_mul])())
                }
            }

            INTIALIZATION FOR OBJECT DECLARATIONS USING ENCLOSED GROUPINGS:
            type si32[a, b, c][(), (4.5), (4.5)]
            type si32[a, b, c] = [type si32(), type si32(), type si32()]
            type si32[a, b, c] = {
                ...
                [1, 2, 4]
            }
            type si32[a, b, c] = a
            type si32[a, b, c](2.4)
            type si32[a, b, c] = [2, 4, 5] * [4, 56, 9]

            ``To delay the construction of an object in a group:
            type [si32, si34]a [ ,3.4]
            ``later on:
            tcast<si32>(a) := type si32(2.3)

            * passsing parenthesis groupings of expressions ?
            fn \"give"(type [si34, si89, si7] _ [, , tcast<b32fp>(5.6‚ÇÉ)])
            {

            }

            infer (a, b) = fcn()
            infer [a, b] = fcn()
        }
        match s{
            case<si32, b32fp> 3
            case(2, 3, 4) 3
            case('3') p.precision_mul(s)
        }
        
        "‚ü¶{3, 4}‚üß"
        "‚ù¥{3, 4, 5}‚ùµ"
        "‚ù∞{2 + 4}‚ù±"
       ·Ñí·Ö°·Ü´
       Ìïú
       üôÖ
       ƒú GÃÇ
       ‚úùÔ∏è

       "{emeka daniel}"
        "emeka daniel is a goat of all things good"

        "
        The easier it is the better eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\
        also badder than ever
        "
        : Should leading and trailing new line characters in a mutline string be part of the string?

        : Should enums be give type parameters? and what are enums all about anyways?
        : enums should be inheritable - efficient code reuse, extending a classes item
        : Greater and less than or equal to can be evaluated differently i.e !(x < y) or !(x > y)
        : The part of it expand to ordinary code should be obeyed, soo...
        {
            üõ∫_isPoor

            if type si32 a = 3, type si34 c = b; e == b: {} ``so is this is an unclosed-grouping? yes it is
            equals :
            if type [si32, si34][a, c] = [3, b]; e == b: {}
        }
        : Concrete definitions for operator overloads
        {
            For binary operations, it the operands must be the same type
            For all operations, it must give the same type as it's operand
        }
        : I would think more about error handling
        {
          - what would io functions do if an io operation fails?
          - what of arithmetic overflow checking?
          - what of opening a file?
          - look at learningcpp.com section on error handling
        }
        : Think more about what and what can have a wide range visibilty in module scope
        {
            all declarations except object
        }
        : Change 'named_st' and 'named_pt' to be 'named_s' and 'named_p'
        {
            named_s a{}
            named_p c{type si32 a, type [b32fp, d32fp] a}
            type unamed_p a(1, 2, 3, 4)
        }
        : Should 'type any' replace 'void*' ability to point to any type? yes
        {
            type any x(34)
            x = 45.6
            x = type fraction(1, 2)

            type any x(b)
            int three = 34;
            void* ptr = &three;
            *(float*)ptr + 2.3

            infer begin_address = cast<ui32>(type raw_ptr(a))
            infer begin_address = cast<ui32>(address_of a)
            begin_address += [1, 3, 4]
            infer some_address = cast<raw_ptr<>>()
            ``raw_ptrs and unchecked heap access violate the invariant
        }
        : Contructed-from and casted-to are similar
        {
            string and string_view
            string: overloaded type casting to cast it's self to string_view
            string: can be constructed from a string_view
            [alternatively]
            string_view: can be casted to a string
            string_view: can be constructed from a string

            Construction is to be used when the construction process is not errorneous
            When a construction is errorneous, it should be casted to instead
        }
        : Warn for dumb things like unnecessary enclosure like this [[[2, 3]], [2, 3], [2]] or (((3)))
            [2, [[2, 3], [4, 5]]] | [f, c]
        : Replace the 'mem' to 'address_of'
        : How would infer be treated in all this? treat like a defined behaviour
        {
            infer a = [type si32(), type si32(), type b32fp()]
            infer a[] ``direct enclosed-grouping initialization is not allowed for 'infer'
            infer [a, b, c] = [...]
            infer [a, b, c] = [a, P, d]
        }
        : Should type parameters be allowed on inferred objects?
        {
            infer a
            is equivalent to :
            type unknown a<type unknown> = 7
            
            a := 3.4
            a<b32fp>
            a<si32>
            
            what of resolving overload conflict strategies?
            cast<b32fp>(a)
            or?
            a<b32fp>
        }
        : No more implict expression argument entry for functions, only for type arguments
        : 'cast' should be reserved for things like tcast<si32>(a) overload-distinction
        {
            type [si32, si8] a
            cast<si32>(a)
            cast<si8>(a)
        }
        : The semantic that describes object construction enforces me to reason more about primitive data-types
        {
            so [ type si32(3) ] is not allowed, only [type si32(3.4)]
            Just use cast for it anyways
        }
        : '_ = x' if you are not using an expression while 'type si34 _ = 9' when you are not using an object declaration
        {
            '_' cannot be used in an expression, so..
            infer _ = x
        }
        : Member operator needs to have a higher precedence than the call operator
        : Delayed construction operator ':='
        : Piping is very different from function entry as it is a stricter form of function calling
        {
          - no default argument entry
          - no default type argument entry
        }
        : What is the high-level-indirection operator even for?
        {
            It is used of identifying ranges, along with the size(len) function
            
            c[1] - It should a requirement for ranges - c(1)

            c[2, 4]
            c[2~4, rng::no_bounds_checking]
            - Is it a function call though? No it isn't, it is an operator
        }

        : Identifier, how would [\"_construct_"] be equal to [_construct_] and [\"_"] be equal to [_]
        {
            fn _construct_(...) {}
            fn _destruct_(me) {}
            fn _move_construct_() {}
            fn _copy_construct_() {}

            what of _v?
            fcn(_v, 1, 2, _v)
        }
        
        : '$' for getting the bits in memory of an object
          no more 'bitcast' because the size of the type is always known at compileTime so, it isn't something the programmer needs bothers his/her self with
          It is even more safe because bitcasting constructs the type-to from the bits of the type-from which is the most unsafe thing that can be done in programming
          And the main reason programmers want to bitcast anyway is to see the bits of the type as unsigned integers not as how they can construct types from bits
          I will still need a way to construct a type from bits, for optimized swap or assignment, or should the language just handle that itself?
        
        : My language gives the invariant that states that every object of a type is always valid from its construction to its destruction
        
        : 'cast' is now free for use üòÅ

        : Memory wise copying should be implemented only by the compiler
          x = ? and y = ?
          ($a) xor_eq ($b)
          ($b) xor_eq ($a)
          ($a) xor_eq ($b)
        : Object expressions are mutable by default

        : Arbitary integer bit sizes from i2 to i65536 2^16

        : Parser error reporting needs to change ???
        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        fn dac<type t1, type t2>(type t2 _){}

        fn dac<type t1, type t2>(type si32 _){}
        dac<s, si3>(23)
        dac<s>(23)
        dac<s>(23)
        
        fn dac<type t>(type t _){}
        dac<si33>(34)
        dac<si32>(34)
        dac<>(34)

        fn dac(type si32){}
        dac(34)

        fn dac<type t1, type t2, type t3>(){}
        fn dac<type(t1, t2, t3)>(){}
        fn dac(){}

        fn dac<type(t1, t2)>(){}

        fn dac<type t1, type t2>(){}
        fn dac<type t1, type t2>(type t1 _){}
        fn dac<type t1, type t2>(type t2 _){}
        fn dac<type t1, type t2>(type (t1, t2) _){}
        fn dac(){}
        fn dac(type (t1, t2) _){}
        
        dac<si2, si3>() -> []
        dac<si3, si4>(34) -> [ dac<si3, si4>(34) ]
        dac<si2>(34) -> [ dac<si3, si4>(34) ]
        dac<>(34, 45) -> [ dac<si3, si4>(34, 45) ]
        dac() -> []
        dac(34, 45) -> []

        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        : Concerning error handling

        name_space error
        {
            named_pt code{type si32 code}
            type_space code
            {
                fn get_msg(me) type u8str
            }
        }

        : How can inheritance model sumType capabilities like my ast Expression
    }
    

    #async type user dum_client()
    
    [I don't want [nc] to be in no way confusing as C++, i want everthing to make sense as much as possible to the average programmer]

    [LCI - language communication interface]

    iter i : (1, 2, #operator(=)) {}
    r_l(23, #operator(=, and))(23, ...+)
    r_l(23, #operator and)(...)
    
    printf("emeka daniel").printf("{23}+{23} .{:0} + .{:0}", 23)
    
    type error::code e;
    e.::message()
    e.message()
    type error::string e;

    Passing types as values in common for generic programming, therefore it is avialable in user code, while returning of types isn't
    Being able to treat types as data is valuable in programming

    type list<si32> x(_v, 1, 2, [+1]...)
    type #exp::getType(2+3) h
    type #type::remove_qualifiers(si32, #type::mutability) c;

    alias no_mutabilty<type t> = type #type::remove_qualifiers(type t, #type::mutability)

    fn geo(){}
    fn geo<type t>(){}
    fn geo<type t = si32>(){}

    ``solved C++'s like templating for all declarations that deal with types, but i still don't know what to call it
    {
        type si32 a<type _> = a
        
        type si32:"&"<>|<>()
        
        fn<type t>(){} ``syntax permits <func_exp> to have generic parameters but nut types

        type si32 a<type t> = #compileTime {
            infer (a, b)
            a = 100, b = 10'000
            
            iter i : (a, b, ...)
                #run_at_compileTime io::out.write(i)

            type t _;
        }

        ``Won't that mean i can overload an identifer using generic types: { pi<b32fp> pi<si34> }
        ``This shit is sooo fucking hard

        number::pi<float>
        std::numbers::e_v<float>;

        type bfpT nums::pi<type bfpT> = {
            if #{type(bfpT) == #type(b32fp)}:
            3.23454
            else
            3.234545

            if #type::is_eq(type bfpT, type b32fp): 3.23454

            #force_compileTime error::panic("Emeka Daniel")
        }

        nums::pi<b32fp>
        nums::pi<b512fp>

        fn dirt<#apply::constraint(si32) type t>()
        {

        }
        fn dirt<#apply::constraint(si33) type t>()
        {

        }
        
        fn dirt<type t>(type si32)
        {

        }
    }
    
    `{
        infer line_number = #file::line_contents::line
        infer column_pair = #file::line_contents::column_pair()
        
        #give::value()
        #give::type()
        #statement::loop::extra::break()
        #concurrency::async
    }`

    ``Reason about generic specialization
    {
        named_pt byte {type ui8 byte}

        named_pt d_array<type dT>
        {
            #{
                if #type(dT) == #type(byte):
                {
                    type bytes data()
                }
                else
                {
                    type heap_ptr<dT> data
                }
            }
            ``or
            type #{ if #type(dT) == #type(byte): give type data else give type dT }
            type si32 (size, capacity) = $() ``this is confusing to me
        }

        named_pt d_array<type dT>
        {
            #_expand_on_evaluation_:
            {
                if #type(dT) == #type(byte):
                {
                    type bytes data()
                }
                else
                {
                    type heap_ptr<dT> data
                }
            }
        }

        type_space cartier<type t>
        {
            #_expand_:
            {
                if #type::is_eq(t, b32fp):
                {}
                else
                {}
            }
        }

        named_pt cartier<type t>{ #type::hide_if(t, b32fp) type t (t<>, p<>)() }

        ``how would i implement <string casting> which requires entry of multiple parameters ?
        tcast<bool>(23)
        tcast<u8str>(23, .base=3, .\"normalize?"=true .\"show pos sign?"=true, .\"show seperator"=true)
        tcast<u8str>(23, true...);

        #constraint<t> = #{
            if #type(t) != #type(u8str): #error::disqualify
        }

        fn tcast<#constraint type new_t, type old_t>
        (type old_t x, type ui6 base(10), type bool \"show pos sign?"(false), type bool \"show sep?"(false))
        {

        }

        named_pt Danny<type t>
        {
            #enable_if(#type::\"!eq?"(si32, t)) type t data
            #
            {
                if #type::\"
            }
        }

        template<typename t>
        fn data<type t>()
        {
            if constexpr (std::is_same<t, std::string>)
            {

            }
            else
            {

            }

            #compileTime
            if #type::\"eq?"(t, astr):
            {

            }
            else
            {

            }
            #
            {
                if #type::\"eq?"(t, astr):
                {

                }
                else
                {

                }
            }
        }

        type_space data<type t>()
        {
            #
            {
                if #type::is_eq(t, u8str):
                #give::entity::declaration( alias fp_sex = namespace floating::sexx )
            }
        }

        ``I do not want code to be runnable directly in the LCI
        tcast<u8str>(2, ...)
    }

    `{
        ``A type has properties

        [type_space]
        - allows for extension of the type properties
        - allows for type_space sharing with unrelated/related types when defining properties for a type(all type centric declarations have this)
    }`

    fcn(1, 2, 3, ...), fcn(1.2, ...) ``disallow un-sepcification of default arguments

    iter i : |1~2|{}

    type rid_of_mutability<#exp::getType(a)> n;

    #info::unhandled_exception
    type heap_ptr<si32> f(@heap_ptr::non_arena)
    type raw_ptr<si32> g()
    tcast<raw_ptr<b32fp>>(type raw_ptr(g))

    #info::handles_exception (type u8str = $()).insert()

    iter i : (1,2)
    #print(i), #output("Emeka Daniel")

    type #[type::T must_be(hashable)] c()

    type #literal::number::integer("si32") b = 0454340092323
    type #literal::char_wise::unicode_char("basic-latin") = '√ü'
    
    #operator(=, and)
    
    ``conflict
    infer a(type si32())
    infer a(type si32(), 3) ``converting constructors won't take the type itself

    * How would i be able to return types? - abstract answer: through the LCI
     - typeof()
     - { type unamed_st<si32, si4> e; if e.get_current_type(): {}? }
    * Think about how comparison of types with mutability should go
    * How to design meta-programming
     - like get line number?
     - get identifier names
     - get function-give-type
     - get name_space contents
     - use literal as types
    * Pre and post condition entry for compiler communication level
    * Really think about what and what compiler communication interface can do
     - should it be used in an expression
     - should it deduce function return types #[fn::getGiveType(dama)]
     - they should embody meta programming and nothing else right?
     - they shouldn't be used to affect async and await right?
    * Think about how attributes should be used in my language(they should have namespace like syntax though: function_body::forLoop::eval_once)
    * CompileTime code runablity
    * Compiler ability to force things like: [must be a return value of a function] or [must call a particular function after object initialization]
    
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    TokenTypes:
    - identifier: rIdentifier and nIdentifier
    - literal: character_wise, number and boolean
    - symbol

    Expressions:
    are items associated with a data type and define their existence as operands that may or may not return/give a value

    Statements:
    are rudimentary lines of code that can only be found in blocks
    
    Declarations: are language abstractions used for the convientent manipulation of data, which the compiler requires explicit information
    on to setup for the programmer to use
     - Definitions: also called declaration definitions are the concrete bodies of declarations
     - Disclosures: also called declaration disclosures are declarations without a concrete body, so they are abstract declarations such that the
       compiler dosen't posses enough information to setup and therefore allow the programmer to use

    Definitions
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ü¶ú üëÅ üå≤

    [Type]:
    a data-type is simply a classification that dictates how a value is to be interpreted and what operations can be performed on that value

    Example:
    A 32bit wide memory can contain this: [11110000 10011111 10001100 10111001]
    When interpreted as a signed integer, the value becomes -257'979'207‚ÇÅ‚ÇÄ
    When interpreted as an unsigned intger, the value becomes 4'036'988'089‚ÇÅ‚ÇÄ
    When interpreted as a utf8 character, the value becomes the unicode character rose üåπ
    When interpreted as a d32fp real, the value becomes nan
    When interpreted as a b32fp real, the value becomes -3.950259@+29
    And so on...
    
    b'3'; u8'√∑'
    type bchar a()
    type si21 c()
    type bchar n = cast<bchar>(c)

    [Object]: an object in nc is an allocated region of memory(either physical or virtual) that stores a value that is associated with a type.
    
    So the requirement of some memory to be called an object in nc are:
    1. The memory must be explicitly allocated, .i.e it must belong to the process
    2. The memory must be contian a value associated with a type
    
    The term used to refer to memory regions that do not fufill the above two conditons are non-objects

    There are two types of object entities in nc:
    1. <object_decl>
    2. <object_exp>
    
    The above two are futher more classified into a general category:
    1. named objects: objects which posses an identifier
    2. unnamed objetcs: objects which do not posses an identifier

    A named object is basically an <object_decl> entity, which requires an <identifier> as part of its declaration.
    An unnamed object is much more broad, it ranges from elements of data structures to <object_exp> entities.
    Here's a full list of them:
    - elements of data structures
    - return values in an expression
    - <object_exp> i.e type int32(2) + (type int32 ::= 78)

    For clarification purposes:
    To be pedantic all expressions in nc return/give an object as its value
    
    |Object Lifetime|: the lifetime of an object is tied to the scope in which it was defined
    Objects defined in expressions have expression scope
    Objects defined else-where have either block or global scope
    
    [Functions]: a function is simply just a block of code, that can be called arbitary in expressions
    Functions in nc aren't objects, but they can be treated like objects to some degree.
    Because function can be treated as objects, they do not support all the features that functions provide
    Like overloading, example:
    In a block scope, an object identifier must be unique to a type i.e
    {
        type int32 a
        type int64 b

        ``a and b can only be redefined as identifiers in objects with differing types than the original
        ``i.e
        type int64 a
        type int32 b

        ``but functions do not share this limitation, they can be redefined using the same identifiers with a condition that either the number
        ``of parameters are different or the types of the parameters are
        ``example:
        fn gang(type int32 _){}
        fn gang(type int64 _){}
        fn gang(type int32 (a, b)){}

        ``for identifers
        type fn(int32)void gang := fn(int32){}
        ``it works because of the redefination of type stuff
    }

    Example:
    {
       ``Reason about what happens when an overloaded function gets assigned to an object of a concerte type or worse an object of an un-guessed type??
        fn fcn(){}
        fn fcn(type i32 _){}
        fn fcn(type i32:"imut" _)
        fn fcn(i1024 _)

        type fn(type i32)type void a;
        a ::= fcn

        guess a ::= fcn
        ```
        compile error: cannot guess the type because the fcn identifier has too many overloadeds
        ```
    }
    
    !a
    not a

    Understanding value categories and referencing
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Values also known pedantically as objects are divided into two categories:
    - abstract-values
    - concrete-values
    
    [Memory reference] references the memory of concrete-values
    [Value reference] references the value of concrete-values but those concrete-values can be results of concrete-value promotion

    A reference is in nc is an object that simply refers to another object in memory. There

    For a function to be treated as a member function, the first parameter must have the function parameter only type
    The function parameter only type works like this:
    {
        fn example(type any: "[]" me)
        {
            if r_l(type ncType(arg.1), ==, or)()
        }

        - Attribute: "[]" -> is a function parameter only type that performs cvalue promotion only if the type is not trivially movable.
         That is, it is a pseudo-value-reference type that favours the promotion of avalues to cvaules within a function call context, only if it
         is not trivially movable.

        - Attribute: "[&]" -> is a function parameter only type that also performs cvalue promotion but with no pre-condition of it being trivially
         movable. That is, it is a reference type(not pseudo-reference) that promotes rvalues to lvaules within a function call context

        - Attribute: "imut []" -> the same with {attribute:"[]"}, but immutable
        
        - Attribute: "imut [&]" -> the same with {attribute:"[&]"}, but immutable
    }
        {
            lvaules always get match to &me
            rvalues always get matched to imut &me

            I need a way of manipulating 
        }
    'imut', 'mv' and 'cp' are lower-marker-prefix-operators parsed as expressions
    '&' is the only higher-marker-prefix-operator that is parsed along with expressions
    
    cp a = b
    imut a * b
    (imut &a) + b

    imut: is a lower-marker-prefix-operator that can be used in type-guessing and immutable-reference inference

    [<object_exp> are not allowed to have type qualifiers]->[they are now allowed]
    (guess ::= &a).fcn() -> has something to do with value-referencing
    type i32(&a).fcn()

    also how can literals have call member functions when they are rvalues: 2.set(2), "33".insert(0) and so on

    [A special root compiler attribute that relaxes some of the rules of the language, example: instead of write(imut &"emeka", imut &3)]
    
    fn dance(&me, i32 (a, b, c)){}
    type_space(Emeka)
    {
        fn dance(me, i32, i8){}
        fn dance(me, i32, i8){ #[copy_function_body_from(dance, fn(&me, i32))] }

        fn normalize(type: "[]" back){}
        fn dance(type: "[&]" me){}
    }
    
    Solidify the entities that require the type prefix
    {
        - Everthing except type argument list and function signature
    }
    Solidify default contruction/initialization
    {
        ``a combination of rust's and c++'s model
        type i32:"imut&" a := imut &23
        type i32 b()

        guess a := &23
        guess b

        if b == 3: fan()
        if b = 3: fan()
        b := 3
        guess a := 2
        :(2, 3)
    }

    name_space E {}
    type_space E {}
}`

`{
    [Bringing back blackjack]

    ("üêÄ" = "\[1f400]") üëÄ

    Why am i storing the token and not referencing it?
    Even line content is just being copied for no reason, a copy on write string would solve this

    The compiler would have a json configuration file
    The build tool would require a json style configuration file

    - I think the character size should be accepted at the semantic level

    The lexer shouldn't be concerned or bother about user-literal-types, it should be concerned about only the tokenization.
    The syntaxer should worry only about parsing the tokens into valid syntax, then transforming that into an ast
    The semantic should worry about the rest

    Literals can become types - it involves the type of meta-programming that allows free form manipulation of certain types of code data

    Number Literals:
    - can be multiline, and that multiline would be would be discarded in the lexer[U+2938 ‚§∏]
    - the digit seperator would follow specific rules, such as it always being amgonst digits and that only one can appear in a sequence
    - they would be type unchecked in the lexer

    CharacterWise Literals:
    - a nc character must be only one unicode character
    - a nc character is not multiline
    - a nc string is a combination of unicode characters of arbitrary sizes
    - strings would support expression interpolation, i.e "emeka daniel is: "\&{ "2"+"3" }&", "{2+3}"

    [Slovable Notes]
    * Ask chat-gpt why underflow for IEEE binary floating-point literal constants are tolerated and rounded to zero in programming languages while
     overflow isn't?
    * Create a visual representation of IEEE binary floating-point using the SFML library
    * A function to accurately calculate the min and max values of IEEE
    - inf/-0 should be implemented right
    * Fun fact: powershell uses '‚àû' instead of 'inf' or 'INF'

    * Reason about why raw identifers should escape reserved identifers?? what is the purpose = interoperability with other languages
     - escaped identifers and escaped raw identifers
    * Remove 'mem', type raw_ptr<?> would suffice
    * Change reserved and identifier to rIdentifier and nIdentifier
    * Changing of signed integers i[n] to si[n]
    * Can literal types take raw-identifiers? example: \"emeka"'üëÄ' or 12343`\"daniel"
     - if not, fix it
    * Make a unicode class that prefectly encompasses all it's encodings
     - Structure utf8 more accurately to support all unicode encodings: utf16, utf32, ucs-2 and so on
    * Remember to add a condition in character function for getting the size when unicode name(\{}) and entity(\()) are introduced
    * Block should be able to transform seemingly normal statements into end expressions when used as an expression
     - i.e{
        type si32 a = {
            if true: 3
            else 90
        }
    }
     - ability to transform end expressions to give values
    * Think about why 'none' needs to be reserved
     - hindsight, current me dosen't want it that way
    * 'panic', 'output', 'tcast', 'bcast' and input shouldn't be a reserved word no more
    * Think strongly about initialization
     - type si32 a() ==? type si32 a = $()
     - How would treat <arg>?
    * Error recovery in the syntxer to be thought of
     - find a fix for something like: (+) or r_l(+)
     - try to outline what the production-rule expands to when logging like in <r_l>, when <r_l_arg_list> is not found or <relational_op>
    * Remove 'defer'
    * Addition of mem operator to replace & which is now a reference operator
    * Should i remove the colon in the match block?
    * Really defined semantics around <arg>
    * Change 'break' arg to accept an integer-number-literal type instead of an identifier
    * A semicolon can be appended to a block that is an expression statement üëÄ
    * Alias should take an <expression> and the multiple special_ident that the others have
    * Remove <jump_statement>s from conditional-expression
    * Think more about which things can be parsed as expressions, for example an <if_statement>
    * Remove 'default'
    * Provide both the 'mut' and 'imut'
    * Remove this @::si32 from [fromType]
    * Change 'guess' to 'infer'
    * [3,,4] for pair expression and [3~4] for inclusive range
     - how would i parse them, as operators? or sole expressions?
    * Why is odd an operator? remove it in favour of member function: 2.isOdd()
    * Check how you did the syntax for the C for loop
    * Should a <block> accept <type_space> and <name_space>? Yes it should
    * Add an alternate parameter entry: [me, imut me, &me, imut &me] -> ['imut']['&']'me'
    * Why do i really need ':=', why can't i use '=' instead
    * Change cp to copy, mv to move and imut to mut. And think about how i should parse them
     - like this: copy(a) + b or this: copy(a + b)
     - Liken them to how rust parses their own
    * Should a <raw-ident> equal a <normal-ident>. Example: \"emeka" == emeka
     - yes they should
    * _v Should be used to opionally start a varg- homogenous or heterogenous
        - fcn(_v, 1, 2, 5, _v)
    * Identifiers with starting with [_] should not be allowed
    * The semantic class should warn about something like this: type si32 a := type si32(3), stating that it is redundant
    * Integer-number-literal with arbitrary sizes up to 10000
     - To be checked in the semantic class
     - Optimize maximum number literal checking
    * identifier shadowing how will i allow it? and rust's style of redefinition
     - This question is deeper than it ought to be, it is similar to how function can be overloaded
    * How would i solve the problem of function overloading semantics example:
     - for objects, if an object can reference an overloaded function through its identifier, should objects with function type have the ability to
       overload themselves using <function_exp> as their source?
     - For overloaded functions and function-objects with multiple call operator overloads, when guessing the function-type, how would that go
    * How will overloaded functions interface
    - {
        fn fcn(){}
        fn fcn(type si32 _){}
        infer a := fcn
    }
    * For nc-happy-size types, copying is the default
    * Something like this '\_' is parsable üëÄ
    * What would not be the discard identifier? '_'
    * '_' would be both the discard and default identifer
    * Should i support any order function parameter entry like in mojo and python? yes i would, just need to define the semantics around it
     - {
            fn e(type si32 a, type b32fp l, type d32fp k){}
            e(.k := 2, _, _)
       }
    * I need a refined semantic for <objetc_exp>
     - Lifetime
     - Being used as function calls to supply multiple arguments to named objects, redefine things like move and copy constructor
     - Being used as standalone expressions
    * Cement semantics around function declarations and how they can be treated like objects
    * Should i create syntactic suger for working with sumTypes?
    * Conditional expression should have a compulsory else expression
    * The enforcement of using [mut &<expression>] should have a clear semantic definition, that allows override when it becomes inconvinient
     - {
            ``instead of:
            io::out(mut &2, mut &3, mut &4, mut &5, mut &6)
            ``do this instead:
            io::cout(2, 3, 4, 5, 6)
       }
    * Create a concrete semantic definition around initialization, should they be allowed to be initialized after the fact?
     - {
            type si32 s
            if i == 3: s = 2 else s = 4
            b = i == 3?(2:4)
            b = { if i==3: give 2 else give 4 }
       }
    * Reason more about the sumTypes in my language, becuase initialization of them are horrendous compared to rust's way
    * nc should be immutable first because a programmer should have a clear reason while coding of what object needs to be mutable, it essentially forces the programmer to reason more about his/her code
     - Due to that, standardize how the new [mut] keyword is going to be used
    * Make looping dynamic using compiler attributes like:
     - in for and iter loop, the modifier should not always be at the end
     {
        iter i:(mut 5, 1)
        {
            #[loop::after_modification_do_this]
            {

            }
            ``or
            #[loop::modify_instead];
        }
        
        for infer a:= 5; a < 1; --a:
        {
            #[loop::after_modification_do_this]
            {

            }
            ``or
            #[loop::modify_instead];
        }
     }
    - in while to help when [continue] is used and it skips the modification expression there causing an infinite loop
    {
        while a < 7:
        {
            if a == 5: continue
            #[loop::modification_exp_mark] ++i;
        }
    }
    * Add the file name of the current file it is compiling, like: current file is main.nc
    * Think more about how expressions at the end of a block would qualify as return values?
    {
        if e * 2 = 3:{
            2
        }
    }
    
    * I want io devices to have a common infertace, like type-casting
    * I want a similar technology of reloading the nc's ast while running as the DOM in javascript or lisp
    * My language needs to be exception safe - read that rust's article about it
    
    * Since assembly languages compute the result of a division as it's quot and remainder, find out if llvm provides a similar function
    * Check if rust does that annoyning stuff of this std::uint32_t(std::int8_t{-3})

    * Can i write something like this: [for (auto i = operand_digit_count - desired_digits; ; ){}] in nc
    * Swapping should use that xor way

    * <block> is going to be parsable in the global space for things like match os::which_os {case(os::windows): case(os::linux): case(os::mac): }
    
    * Add support for nc decimal floating point 8 and 16
    
    * Unicode name and entity entry would be left for another time
    * Unicode name check and replacement with the code-point entry be addressed - would be done in the semantic

    * Support for range loops; possible syntax: 'rng' <identifier_list> ':' <expression_list> <statement>
     - A range operator for number literals -> [1~3]
    * Add catch block; syntax: 'catch' ['(' [<parameter_list>] ')'] <block>
     - until i study exception implementation

    * Add generics, varadic generics and specialization of said generics support
     - Constraints should be added to enrich generics
    * Think about how multiple files would interact with one another[nc_impl, nc_inf, nc and (the import system)]
     - i.e think more about the import system of nc
    * arena_ptr and non_arena_ptr are the two heap allocation objects we have in nc
    * think more about slices
     - A general concept is needed to classify range data structures and that concept would be iterators
     - And the common interface for using data-structures
    * Reflect more on the part of the static analyzer that enforces memory safety
     - How safe are pointers going to be
    * What of this [simd] type?
    * Think about error handling for my language .i.e things like: error::code, error::msg, error::panic, exceptions and so on

    : A compiler tool that explains the nc code, would be avialable in the LCI directly too

    * What happens when a <rng> references a range mutably and one tries to modify the range(collection)?
    {
        guess int32_darr := type d_array(_v, 1, 2, 3, 8, 9, 0)
        rng i : i32_darr
        {
            io::out(i)
            i.erase(2, 3, 5)
        }
        iter i : |i32_dar| io::out(i), i.erase(2, 3, 5)

        infer si32_dArray := type dArray(_v, 1, 2, 3, 4, 5, 6)
        iter i : mut si32_dArray
        io::out.wrt(i), i.act()
    }
    _______________________________________________________________________________________________________________________________________________    

    something like this is very dangerous:
    {
        type astr a() type ui count()

        a.assign(a.begin() + count, a.end())

        ``because function @astring::assign(type astring:"immut l-ref", type @astring::iterator, type @astring::iterator) dealloctes itself
    }
    _______________________________________________________________________________________________________________________________________________

    [Unsolvable Notes]
    * Positional base agnostic precision arithmetic for integers
    * A negative index should be interpreted from the back for subscripting
    * For total-ordering, a special function that returns boolean values for equality and lessthan
    * The convention of defining relational operators is to encourage defining only equality and lessthan
    * My string implementation would be [copy-on-write], meaning it initially has a view to the string until a write operation is triggered
    * imbedding of markup languages like html and styling languages like css in my language to be used in the web
    * for classes, allow the default function parameter be a member variable not like c++, i.e. type uint32 e ::= me.absoluteColumn
        {
            The above won't work, just tell the user that default arguments are compileTime constructs while member objects are runtime
            constructs, but it can be achieved by overloading
        }
    * Warn about function identifiers not being called
    * Moving should be the default instead of coying
    * When implementing unsigned addition, make it like this: max(lhs, rhs) - min(lhs, rhs); to prevent reckless overflow
    * When converting from a lesser signed to a greater unsigned integer, disregard the sign and perform a clean conversion
        {
            (type int8 -> type uint32) != (type int8 -> type int32 -> type uint32)
            but this:
            (type int8 -> type uint32) != (type int8 -> type uint32)
        }
    * How would the compiler differentiate between something like this:
        {
            type u8_str e('2'u8, '4'u8, '3'u8)
            type u8_str d(e.iterator_start(), e.iterator_end())

            what if i want the template type to be an iterator

            template<varadic T> _construct_(type T t);
            template<T iterator> _construct_(type iterator start, type iterator end)

            same problem goes for how the size would be inputted
        }
    * built in static array, dynamic array, list, map, uo_map, stack, queque, set: all data structures i hope to implement
    * functions for integers
        {
            - zero
            - isPos
            - mem_layout
        }
    * algorithmns for data-structures
        {
            - shift_left
            - shift_right
            - count_sequential
            - find_from : takes an index to start finding from, then returns the result plus the offset to get an accurate index
                {
                    - drawbox_around_text::spacing needs it for handling of newline inputs
                    - in file ncLog.h slipt needs it to locate the delimeter(m)
                }
            - slipt
            - during comparsion, a pair should be taken indicating the start position for comparsion for the two operands, similar to find_from
            - find_first_sequential
            - count_sequential_until_c_is_greater_than_n: \"count sequential until c > n"
        }
    * my own regex implementation that embodies clarity and brevity - inspired by EBNF
     - it's syntax won't be conventional
     - it will support extraction without checking
     - it give clear error messages if the syntax is wrong
     - it will support error recording for the parts of strings that don't match ??
     {
        Find and replace
        "emeka@cyril.com"
        "<unicode:all_lang_alphabets> '@' ['gmail'|'hotmail'|'outlook'|'yahoo'] ['.'] 'com'|'n_com'"
        
        match_str[1] = "nc_mail"
        match_str[2] = "nc"
     }
    * my own list implementation that provides random access without that need of an internal array
    * editor features
    {
        - arbitrary selection of highlighted text starting from a start to end line: turns out vscode already has, depending on where the cursor is, hold shift down and click on an location you want
        - movement of highlighted or focused text to arbitary locations: can be able to apply whitespace inducing keys on it
        - bookmarking for highlighted or focused text and lines
        - keybindings for spwaning and despwaning the sugggestion window: truns out vscode uses the escape key for it
        - highlight lines with only whitespace and lines ith trailing whitespace
        - backspace and delete would be set to remove a grapheme-cluster by default while shift+backspace gives the option of deleting par code-point
    }
    _______________________________________________________________________________________________________________________________________________

    *11110000 10011111 10001100 10111001
    *            11111   001100   111001 -> correct
    *            11111     1100 00111001 -> wrong
    *
    *
    *[11110]000 [10]011111 [10]001100 [10]111001

    match e {
        case(1, 2, 3, 4) {
            
        }
        case(1~4) {

        }
    }

    match type unamed_st(1, 2.333`b32fp) : i{
        case<si32, b32fp>{

        }
        case<>
        case<si45> e + 4
    }

    for i, j, k : (!{default, 0, 0}, <, 32, !{1, 1, 1})
    io::stdout.write(i)

    for i, j, k : (!(23, 0, 0), 32, !(1, 3, 5))

    iter i, j, k : ($(23, _, 9), .end := 32, )

    true or false and true or false
    (true or (false and true)) or false :[ C/C++ parse]
    true or (false and (true or false)) :[ nc parse ]

    u8"
    Emeka Daniel at 2003
    \"Emeka\"
    \n
    "
    a"
    ${3, 3}
    \u{
        Emeka Daniel
     }
    \u[2222'222]
    "
    ¬´Emeka, Daniel¬ª

    d(i, f(e, 9))
    i.::d(e.::f(9))
_______________________________________________________________________________________________________________________________________________
    Intermediate arithmetic base(10) digits requirements

    - [Multiplication]:
        lhs and rhs should be converted to the result's integer type when computing
        prove: (9{max_real_part}¬≤).digit_count()

        b32fp(7+7 == 14 digits) -> si49
        b64fp(16+16 == 32 digits) -> si109
        b128fp(35+35 == 70 digits) -> si235
        b256fp(73+73 == 146 digits) -> si488
        b512fp(149+149 == 298 digits) -> si993

    - [Division]:
        - [lhs < rhs]: leading zeros are accounted for, we can prove it by using two methods
        Only the lhs need the integer of such size
        
        prove(1): (9{max_real_part-1} √∑ 9{max_real_part}).digit_count() + {implementation_precision+1}.digit_count()
        lhs = 9{max_real_part-1}
        lhs.digit_count() + {implementation_precision+1}.digit_count()
        
        prove(2):
        lhs = 1 √∑ 9{max_real_part}
        1 + {number_of_leading} + {implementation_precision+1}

        b32fp(7+8 = 15 digits) -> si50
        b64fp(16+17 = 33 digits) -> si110
        b128fp(35+36 = 71 digits) -> si236
        b256fp(73+74 = 147 digits) -> si489
        b512fp(149+150 = 299 digits) -> si994
    
    - [Addition]:
        {implementation_precision+1} + 1

        b32fp(7+1+1 = 9 digits) -> si30
        b64fp(16+1+1 = 18 digits) -> si60
        b128fp(35+1+1 = 37 digits) -> si123
        b256fp(73+1+1 = 75 digits) -> si250
        b512fp(149+1+1 = 151 digits) -> si502

    - [Subtraction]:
        b32fp(7+1 = 8 digits) -> si27
        b64fp(16+1 = 17 digits) -> si57
        b128fp(35+1 = 36 digits) -> si120
        b256fp(73+1 = 74 digits) -> si246
        b512fp(149+1 = 150 digits) -> si499

    What I don't like about Rust:
    - the assignment operators don't return the subject of the assignment
    - it dosen't have the concept of value categories
    - it did away with useful operators like [++]
    - why do away with c's for loop syntax?
    - no overloading of any sort: function and operator that is
    - no idea of default parameters
}`