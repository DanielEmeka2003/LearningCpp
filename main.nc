// [singleLine-discard-comment]
/* [multiLine-discard-comment] */
`` [singleLine-doc-comment]
`{ [multiLine-doc-comment] }`

//9.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999₃₂@+16383`d32 xxxxxxxxxxxxx ppppppppppppp

`{
    Rules regarding coloring error output
    ──────────────────────────────────────
    1. If a text is too be colored, it must do so with it's background change to black.
    Reason: to better enchance the surrounding of the text, resulting in better display and it also helps avoiding vanishing of the text when the
    color of the text happens to be the same as the terminal background
    2. If a text begs for enchancement, enboldening the text is more apt than coloring
    3. Text belonging to a line, i.e. [Line Contents:], should always be on a black ground background, primarliy to show the whitespace from that
    line if any

    Definitions
    ───────────
    Object: an object in nc is an allocated region of memory(either physical or virtual) that stores a value that is associated with a type.
    Type of objects in nc:
    1. named objects
    2. un-named objetcs
    3. temporary objects
    4. callable objects
    
    Functions: functions are objects that store no actual data used in manipulation but instead refer to a block of instructions that can be called
    to evaluate those instructions and then return a value. In nc, they are referred to as callable objects

    objects of function types
    functions
    function object
    
    Void Type: the nc language's default type that embodies nothingness - similar to digit 0 for numbers.

    Declarations
    Disclosures
    Definitions
}`

fn jester() void
{
    //iter 2 : (default, =, .step ::= 2)
    //r_l(+)
    //type int32 match
    //if
    //r_l()()
    //r_l()+3
    type daniel &daniel ::= 4
    
    r_l( 90)(,)

    r_l(90, =, and)()

    `{
        - sRparen is not to be skipped
    }`
}

fn sum()
{
    `{ multi-line comment `{}`  }`
    ``single line comment ⟨⟩ `% - %` `!

    ``for none : (default, ≠, 23)
    
    io::cout.write("emeka \[2'FF'0] ")

    type int32:"immut-lref" a ::= 34
}

``enum Theta: int32 { ead, error, fase ::= 23 };

`{
    namespace Awesome::Daniel::Main
    {
        sumType daniel
        {
            int32,
            int64
        }
    }

    named_st 🛺_isPoor ``sumType declaration
    { bin32fp, u8string }

    named_pt 👀_😈 ``productType declaration
    { int32 a, pstring c }
    
    fn 👩🏿👀(int32 a(23), int32, u8string g ::= "er") void ``function declaration
    {
        while (true)
        io.sing()
    }
    guess (a, c, d, e) ::= arg(2, type int32(3), 3, 0.)
    #(2, 3, 4, 5)|fcn
    arg(2, 3, 4, 5)|fcn
}`

fn language() ``fixing accidental C-style syntax and expression-list error
{
    ``f(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);

    ``d.::fcn();
}

//👩🏿 = 👩+ 🏿

fn main() int32
{
`{
    !((int32, achar)int32) a := 9
    type fn (int32, achar)int32 a ::= main

    2 + {5 = 9 - 8 * 0}
    {3} + 5
    {4} - {if(8) give {0}}
    2 + 3? 1:8 *3;
    +-@34
    e({}, {+5})

    r_l(=, and, 23)(12, {23}, 8)
    a(2, 6, {})

    tcast<int32>;
    
    fn(int32 a, int32 b){ a * b }
    bcast<int32>()

    iter _ : (default, 23, -2, ≠)
    io::cout.write("emeka")
}`
    io::get_string()
}

`{ --commented-out--
namespace A
{
    namespace B
    {
        namespace C
        {
            namespace D
            {
                namespace E
                {
                    sumType ErrorCase;
                    type_alias E := !(()int32);
                }
            }
        }
    }
}

enum Father : bool
{ daniel, diego ::= 23, gatsby(-23) }

"
\#{emeka daniel\l\j}#  \##{"emeka daniel\c\m\l}##
\##{"emeka daniel\c\m\l}##
\[1'114'111₁₀]
"
}`